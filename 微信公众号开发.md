# 微信公众号开发(订阅号subscription)

[toc]

## 一	公众号	测试号开发

### -1	规划:

#### 1.普通开发

#### 2.Python开发

#### 3.Django开发

#### 4.自动化开发





### 0	整体流程概述

> 1.webstorm编写node框架的开发者服务器,并启用
>
> 2.开启ngrok服务,内网穿透,ngrok http host,指定开发者服务器端口号
>
> 3.开发者服务器编写有效性验证模块,交互,微信开放平台,注册测试号,填写相关内容申请
>
> 4.申请access_token,

> 提供业务服务于用户管理能力的服务平台

> 种类:订阅号(1次消息/天);服务号(4次消息/月);小程序;企业微信

> 普通用户,使用测试号接口权限开发

> 基本交互流程: 用户客户端 <--> 微信服务器 <-->开发者服务器

> 测试接口需要填写域名的时候,使用ngrok生成
>
> ngrok 服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发) ngrok的官方服务可以在 [这里查看](https://ngrok.com/) 由于一些原因 有些同学可能打不开官方网站，国内访问不了，万幸的是ngrok 1.7版本的代码是开源的。本屌恰好有一个未到期的云服务器，且有一个闲置的已备案域名。 本着独乐乐不如众乐乐的精神，本屌不辞劳苦搭建了个ngrok的服务（小米球ngrok），来造福开发者。

| 序号 | 英文         | 中文                 | 备注             |
| ---- | ------------ | -------------------- | ---------------- |
| 1    | signature    | 微信加密签名         | req.query        |
| 2    | echostr      | 微信的随机字符串     | 返回给微信服务器 |
| 3    | timestamp    | 时间戳               |                  |
| 4    | nonce        | 微信的随机数字       |                  |
| 5    | appDI        | 测试号ID             |                  |
| 6    | appsecret    | 测试号密码           |                  |
| 7    | token        | 令牌                 |                  |
| 8    | access_token | 全局唯一接口调用凭据 |                  |
| 9    | exprie       | 失效                 | exprie_in        |
| 10   | credential   | 凭证                 |                  |
| 11   | grant        | 授权                 |                  |
| 12   | openid       | 用户微信id           |                  |
| 13   | utils        | 工具文件夹           | 存放工具js       |
| 14   | reply        | 回复                 |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |
|      |              |                      |                  |



### 1.申请测试接口

![image-20211213121424917](C:\Users\72985\AppData\Roaming\Typora\typora-user-images\image-20211213121424917.png)



#### 1.URL

>  使用ngrok生成本机代理
>
> 登录官网,注册用户,添加token,启动服务器 ngrok http 3000
>
> ![image-20211213121610284](C:\Users\72985\AppData\Roaming\Typora\typora-user-images\image-20211213121610284.png)

#### 2.Token 

> 自己定义

#### 3.写express服务器

```js
//1.引入express模块
const express = require('express');
//引入sha1模块
const sha1 = require('sha1');

//2.创建app应用对象
const app = express();

//3.验证服务器的有效性
//3.1 微信服务器要知道开发者服务器是哪个
//    URL:在测试号管理页面上填写URL开发者服务器地址,使用ngrok内网穿透,将本地端口开启的服务映射为外网可以访问的网址
//    指令 ngrok http 3000;
//    Token:自己填写
// 3.2 开发者服务器 验证消息是否来自微信服务器
      //目的:计算得出signature和微信传递过来的signature进行对比,如果一样说明来自微信服务器;
      // 算法: 1.将参与微信加密签名的三个参数(timestamp,noce,token),组合在一起,按照字典排序,并组合在一起,形成数组,将数组拼接成一个字符串)
      //      2.将数组进行sha1加密(npm i sha1)
      //      3.加密完生成signature ,和微信发来的一样就是验证成功
      //        3.1 如果一样,返回echostr给微信服务器
      //        3.2 如果不一样,返回error给微信服务器

//定义配置文件
const config = {
    token:'13696812048',
    appID :'wxbbb63c35cff0a39a',
    appsecret:'8930f0e111b0677d21a021e0043adb9a',

}


app.use((req,res,next)=>{
  //app.use() 可以接受处理所有消息
    console.log(req.query);
    // {
    //     signature  微信加密签名:     '000f1cd7ba43ff131842ed2322799797811462ad',
    //     echostr    微信的随机字符串:  '1261338858893081587',
    //     timestamp  时间戳:          '1639369585',
    //     nonce      微信的随机数字:    '243436994'
    // }
    //1.将参与微信加密签名的三个参数(timestamp,noce,token),组合在一起,按照字典排序,并组合在一起,形成数组,将数组拼接成一个字符串)
    //对象解构赋值,获取相应的数据
    const {signature,echostr,timestamp,nonce} = req.query;
    const {token} = config;
    const arr = [timestamp,nonce,token];
    const arrSort = arr.sort();
    const str = arr.join('');
    //2.将数组进行sha1加密(npm i sha1)
    const sha1Str = sha1(str);
    console.log(typeof(sha1Str),typeof(signature),echostr);
    //3.加密完生成signature ,和微信发来的一样就是验证成功
    console.log(req.method)
    if (sha1Str == signature) {
        console.log('ok')
        res.setHeader('Content-type','text/html;charset=utf-8');
        //res.setHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        res.send(echostr);

        //lDYD9uxVyUxUgXBOu7ISmmPB6JjKlZupASdbXKiocOR
    } else {
        //res.setHeader('Content-type','text/html;charset=utf-8');
        res.send('error');
    }
});

//4.监听端口号
app.listen(3000,() => console.log('服务器启动成功了!'));
```

开启开发者服务器

![image-20211214081524498](C:\Users\72985\AppData\Roaming\Typora\typora-user-images\image-20211214081524498.png)

#### 4.验证成功

![image-20211213203717401](C:\Users\72985\AppData\Roaming\Typora\typora-user-images\image-20211213203717401.png)

### 2	获取access token

```js
/*
* 获取access_token 调用全局接口的唯一凭证
*  1.有效期: 7200s,提前刷新
        *https请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET
        参数	是否必须	说明
        grant_type	是	获取access_token填写client_credential
        appid	是	第三方用户唯一凭证
        secret	是	第三方用户唯一凭证密钥，即appsecret
*
*  2.思路:
*    1.首次获取,后保存为本地文件
*    2.第二次后,先读取本地,过期,重新获取,覆盖原文件;没过期直接使用
*
*  3.最终: 定义四个方法 在类里面定义四个方法
*     读取本地文件                      readAccessToken()
*          (1)有文件:判断是否过期        isValidAccessToken()
*               A过期:重新获取,覆盖原文件 getAcccessToken()
*                                     saveAccessToken()
*               B没过期:直接使用
*          (2)没有文件(第一种场景,首次获取):
* */
//引入fs模块
const {writeFile, readFile} = require('fs');

//引入request-promise-native,用来Ajax请求
const rp = require('request-promise-native')

//导入配置数据
const {appID, appsecret} = require('../config')

class Wechat {
    constructor() {

    }

    /*获取access_token*/
    getAccessToken() {
        //定义请求地址
        const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appID}&secret=${appsecret}`;
        //服务器端无法发送Ajax请求,需要使用request,request-promise-native库(使用原生node.js包装的库,可以让返回值是promise对象,保证执行没有问题)实现

        return new Promise((resolve, reject) => {
            rp({method: 'GET', url, json: true})
                .then(res => {
                    console.log(res);
                    // {
                    //     access_token: '51_GpmAmGO_0X_l6goi76F2G6gTrNIfHwG2dxXQbRzKeYjrLazb_KehabaO-fY68Uqci62LcEQv4fdLsIVp0UDWORhl9khsr8llMshYYbbYpQyog2hDJk_ij1p9cnYFpojgGoU7L6ZSVIJiv6HsPVLiAJATZP',
                    //         expires_in: 7200
                    // }
                    //设置access_token的过期时间
                    res.expires_in = Date.now() + (res.expires_in - 300) * 1000;
                    //将对象返回出去,将Promise对象状态改为成功
                    resolve(res);

                })
                .catch(err => {
                    console.log(err);
                    reject('getAccessToken方法出现问题.' + err);
                })
        })
    }

    /*
       保存access_token
    *     @param   accessToken  要保存的凭据

    */
    saveAccessToken(accessToken) {

        return new Promise((resolve, reject) => {
            //将对象转换成json字符串
            accessToken = JSON.stringify(accessToken);
            //将access_token保存一个文件
            writeFile('./accessToken.txt', accessToken, err => {
                if (!err) {
                    console.log('文件保存成功!');
                    resolve();
                } else {
                    reject('saveAccessToken方法出了问题,' + err);
                }
            })
        })
    }

    /*读取本地文件中的access_token*/
    readAccessToken() {
        return new Promise((resolve, reject) => {
            readFile('./accessToken.txt', (err, data) => {
                if (!err) {
                    console.log('文件读取成功!');
                    //将字符串转换json
                    data = JSON.parse(data);
                    resolve(data);
                } else {
                    reject('readAccessToken方法出了问题,' + err);
                }
            })
        })
    }

    /*判断access_token方法*/
    isValidAccessToken(data) {
        //检测传入的参数是否有效
        if (!data && !data.access_token && !data.expires_in) {
            return false;
        }

        //检测access_token是否在有效期内
        // if (data.expires_in < Date.now()) {
        //     //过期了
        //     return false;
        // } else {
        //     //没有过期
        //     return true;
        // }

        return data.expires_in > Date.now();
    }

    //获取没有过期的access_token @return { Promise<any>} 返回包装成Promise对象的access_token.
    fetchAccessToken() {

        //优化
        if (this.access_token && this.expires_in && this.isValidAccessToken(this)) {
            //之前保存过access_token并且有效,可以直接使用
            return Promise.resolve({
                access_token: this.access_token,
                expires_in: this.expires_in
            })
        }

        //完整逻辑
        return this.readAccessToken()
            .then(async res => {
                //本地有文件
                //判断是否过期
                if (this.isValidAccessToken(res)) {
                    //有效
                    return Promise.resolve(res);
                    //resolve(res);
                } else {
                    //过期
                    const res = await w.getAccessToken();

                    //保存下来(本地文件)
                    await this.saveAccessToken(res);

                    //将请求回来的access_token返回出去
                    resolve(res);
                }
            })
            .catch(async err => {
                //本地没有文件,重新获取
                const res = await w.getAccessToken();

                //保存下来(本地文件)
                await this.saveAccessToken(res);

                //将请求回来的access_token返回出去
                return Promise.resolve(res);
            })
            .then(res => {
                //将access_token挂载到this上,箭头函数对象是最外层的实例对象
                this.access_token = res.access_token;
                this.expires_in = res.expires_in;

                //返回res包装一层Promise成功对象
                return Promise.resolve(res);
            })
    }
}

//模拟测试
const w = new Wechat();

w.fetchAccessToken()
    .then(res => {
        console.log(res);
    })
```

### 3	获取用户发送的消息

```js
//验证服务器有效性 中间件函数

//引入sha1模块
const sha1 = require('sha1');

//引入config模块
const config = require('../config');

module.exports = () => {
    //函数的返回值即是中间件函数,好处,当函数调用可以传递参数,
    return (req,res,next)=>{
        const {signature,echostr,timestamp,nonce} = req.query;
        const {token} = config;
        const sha1Str = sha1([timestamp,nonce,token].sort().join(''));
        //微信服务器发送两种类型的消息给开发者服务器
        
        if (req.method === 'GET') {
            //1.get 验证服务器有效性
            if (sha1Str === signature) {
                res.setHeader('Content-type','text/html;charset=utf-8');
                res.send(echostr);
            } else {
                res.send('error');
            }
        } else if (req.method === 'POST') {
            //2.post微信服务器将用户发送的数据转发给开发者服务器
            //     验证消息来自微信服务器
            if (sha1Str !== signature) {
                res.end('error');
            }
            console.log(req.query);

        } else {
            res.end('error');
        }


    }
}
```

<img src="C:\Users\72985\AppData\Roaming\Typora\typora-user-images\image-20211214151741713.png" alt="image-20211214151741713" style="zoom:50%;" />

> 微信服务器给开发者服务器返回的req.query ,多了openid   ,用户微信id

![image-20211214151756557](C:\Users\72985\AppData\Roaming\Typora\typora-user-images\image-20211214151756557.png)

```js
//接收请求体的数据,流式数据
            const xmlData = await getUserDataAsync(req);
            //console.log(xmlData);
            // <xml><ToUserName><![CDATA[gh_5215bbd86051]]></ToUserName> 开发者id
            //     <FromUserName><![CDATA[oXKiu6jxH7FPb93gY1qHgu2za_IY]]></FromUserName>                                                        用户openid
            //     <CreateTime>1639473594</CreateTime> 发送的时间戳
            //     <MsgType><![CDATA[text]]></MsgType> 发送消息类型
            //     <Content><![CDATA[/:8*]]></Content> 发送的内容
            //     <MsgId>23471617625295866</MsgId>    消息id
            // </xml>
```

> 引入xml2js库,获取js对象
>
> ```js
> {
>   xml: {
>     ToUserName: [ 'gh_5215bbd86051' ],
>     FromUserName: [ 'oXKiu6jxH7FPb93gY1qHgu2za_IY' ],
>     CreateTime: [ '1639474450' ],
>     MsgType: [ 'text' ],
>     Content: [ '天啊' ],
>     MsgId: [ '23471631196524874' ]
>   }
> }
> 
> ```
>
> 格式化数据
>
> ```js
> //格式化数据
>     formatMessage (jsData) {
>         let message = {};
>         //获取xml对象
> 
>         jsData = jsData.xml;
>         console.log(jsData)
>         //判断数据是否是一个对象
>         if (typeof jsData === 'object') {
>             //遍历对象
>             for (let key in jsData) {
>                 //获取属性值
>                 let value = jsData[key];
>                 //message[key] = value[0];
>                 //过滤掉空数据
>                 if (Array.isArray(value) && value.length > 0) {
>                     message[key] = value[0];
>                 }
>             }
>         }
>         return message;
>     }
> ```
>
> 常见错误原因
>
> 假如服务器无法保证在五秒内处理并回复，必须做出下述回复，这样微信服务器才不会对此作任何处理，并且不会发起重试（这种情况下，可以使用客服消息接口进行异步回复），否则，将出现严重的错误提示。详见下面说明：
>
> 1、直接回复success（推荐方式） 2、直接回复空串（指字节长度为0的空字符串，而不是XML结构体中content字段的内容为空）

### 4	定义回复消息模板

> 创建回复消息模板template.js
>
> ```js
> else if (options.msgType === 'music') {
>         replyMessage += `<Music>
>                             <Title><![CDATA[${options.TITLE}]]></Title>
>                             <Description><![CDATA[${options.DESCRIPTION}]]></Description>
>                             <MusicUrl><![CDATA[${options.MUSIC_Url}]]></MusicUrl>
>                             <HQMusicUrl><![CDATA[${options.HQ_MUSIC_Url}]]></HQMusicUrl>
>                             <ThumbMediaId><![CDATA[${options.media_id}]]></ThumbMediaId>
>                           </Music>`
>     }
> ```
>
> 其中media_id是本地上传到微信服务器的媒体数据,返回的media_id值
>
> 工作流程:开发者上传媒体数据,将微信服务器返回的media_id发送给用户,用户才可以看到对应的媒体数据
>
> 

<xml>
                        <ToUserName><![CDATA[gh_5215bbd86051]]></ToUserName>
                        <FromUserName><![CDATA[oXKiu6jxH7FPb93gY1qHgu2za_IY]]></FromUserName>
                        <CreateTime>1639496288924</CreateTime>
                        <MsgType><![CDATA[text]]></MsgType><Content><![CDATA[大吉大利,今晚吃鸡!]]></Content></xml>

<xml>
                                  <ToUserName><![CDATA[oXKiu6jxH7FPb93gY1qHgu2za_IY]]></ToUserName>
                                  <FromUserName><![CDATA[gh_5215bbd86051]]></FromUserName>
                                  <CreateTime>1639496428770</CreateTime>
                                  <MsgType><![CDATA[text]]></MsgType>
                                  <Content><![CDATA[大吉大利,今晚吃鸡!]]></Content>
                                </xml>











## 二	公众号 	正式号开发

